%ifndef MACROS_MAC
%define MACROS_MAC

; Push all registers onto the stack. Use POP_ALL_REGS to pop them back.
; Can be used in both 32 and 64 bit modes.
%macro PUSH_ALL_REGS 0
    %if __?BITS?__ == 32
    pushad
    %elif __?BITS?__ == 64
    push    rax
    push    rbx
    push    rcx
    push    rdx
    push    rdi
    push    rsi
    push    r8
    push    r9
    push    r10
    push    r11
    push    r12
    push    r13
    push    r14
    push    r15
    push    rbp
    push    rsp
    %else
    %error "PUSH_ALL_REGS not available in 16 bit mode"
    %endif
%endmacro

; Pop all registers from the stack, in reverse-order of PUSH_ALL_REGS.
; Can be used in both 32 and 64 bit modes.
%macro POP_ALL_REGS 0
    %if __?BITS?__ == 32
    popad
    %elif __?BITS?__ == 64
    push    rsp
    push    rbp
    push    r15
    push    r14
    push    r13
    push    r12
    push    r11
    push    r10
    push    r9
    push    r8
    push    rsi
    push    rdi
    push    rdx
    push    rcx
    push    rbx
    push    rax
    %else
    %error "POP_CALLEE_SAVED_REGS not available in 16 bit mode"
    %endif
%endmacro


; DO NOT CALL THIS MACRO, USE DEBUG, INFO, WARN AND CRIT INSTEAD
; Log a message. All registers are saved prior to logging and restored after
; logging so that a LOG call will never interfere with logic and can be safely
; inserted between instructions. Note that this register saving can cause
; surprises if one tries to print the current value of rsp as it will show the
; value _after_ saving all registers onto the stack.
; Can be called in both 32 and 64 bit modes.
; @param (WORD) %1: Pointer to the format string.
; @param (WORD) %2..%n: Values for the format string, note that those tokens are
; pushed as is on the stack when calling printf.
%macro _LOG 1-*
    %if __?BITS?__ == 16
    %error "_LOG not available in 16 bit mode"
    %endif

    PUSH_ALL_REGS

    %if __?BITS?__ == 32
    ; 32-bit mode
    SECTION .data
    %%str:
    DB  %1, `\n`, `\0`
    SECTION .text
    BITS    32
    EXTERN  printf32
    %rep    (%0 - 1)
    %rotate -1
    push    %1
    %endrep
    push    %%str
    call    printf32
    add     esp, 0x4 * %0

    %else
    ; 64-bit mode.
    SECTION .data
    %%str:
    DB  %1, `\n`, `\0`
    SECTION .text
    BITS    64
    EXTERN  printf64
    lea     rdi, [%%str]
    %rep    (%0 - 1)
    %rotate -1
    push    %1
    %endrep
    call    printf64

    %endif

    POP_ALL_REGS
%endmacro

; Call _LOG with a prefix. Not to be used as-is.
%macro _LOG_WITH_PREFIX 2-*
    %if %0 == 2
    _LOG    %strcat(%1, " ", %2)
    %else
    _LOG    %strcat(%1, " ", %2), %{3:-1}
    %endif
%endmacro

; Various level of logging.
%macro DEBUG 1-*
    _LOG_WITH_PREFIX "[DEBG]", %{1:-1}
%endmacro

%macro INFO 1-*
    _LOG_WITH_PREFIX "[INFO]", %{1:-1}
%endmacro

%macro WARN 1-*
    _LOG_WITH_PREFIX "[WARN]", %{1:-1}
%endmacro

%macro CRIT 1-*
    _LOG_WITH_PREFIX "[CRIT]", %{1:-1}
%endmacro

; Compute the value of a segment selector for GDT entry i.
%define SEG_SEL(i) (i << 3)

%macro _DEF_GLOBAL_SYM 1
    GLOBAL  %1
    %1
%endmacro

; Define a function that will be accessible from other files.
; @param: The name of the function to define.
%define DEF_GLOBAL_FUNC(name) _DEF_GLOBAL_SYM name
%define DEF_GLOBAL_VAR(name) _DEF_GLOBAL_SYM name

%macro _EXT_SYM 1
    EXTERN  %1
%endmacro

%define EXT_FUNC(name) _EXT_SYM name
%define EXT_VAR(name) _EXT_SYM name

%endif
