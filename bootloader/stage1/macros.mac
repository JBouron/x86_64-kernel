%ifndef MACROS_MAC
%define MACROS_MAC

; Push all registers onto the stack. Use POP_ALL_REGS to pop them back.
; Can be used in both 32 and 64 bit modes.
%macro PUSH_ALL_REGS 0
    %if __?BITS?__ == 32
    pushad
    %elif __?BITS?__ == 64
    push    rax
    push    rbx
    push    rcx
    push    rdx
    push    rdi
    push    rsi
    push    r8
    push    r9
    push    r10
    push    r11
    push    r12
    push    r13
    push    r14
    push    r15
    push    rbp
    push    rsp
    %else
    %error "PUSH_ALL_REGS not available in 16 bit mode"
    %endif
%endmacro

; Pop all registers from the stack, in reverse-order of PUSH_ALL_REGS.
; Can be used in both 32 and 64 bit modes.
%macro POP_ALL_REGS 0
    %if __?BITS?__ == 32
    popad
    %elif __?BITS?__ == 64
    pop     rsp
    pop     rbp
    pop     r15
    pop     r14
    pop     r13
    pop     r12
    pop     r11
    pop     r10
    pop     r9
    pop     r8
    pop     rsi
    pop     rdi
    pop     rdx
    pop     rcx
    pop     rbx
    pop     rax
    %else
    %error "POP_CALLEE_SAVED_REGS not available in 16 bit mode"
    %endif
%endmacro


; DO NOT CALL THIS MACRO, USE DEBUG, INFO, WARN AND CRIT INSTEAD
; Log a message. All registers are saved prior to logging and restored after
; logging so that a LOG call will never interfere with logic and can be safely
; inserted between instructions. Note that this register saving can cause
; surprises if one tries to print the current value of rsp as it will show the
; value _after_ saving all registers onto the stack.
; Can be called in both 32 and 64 bit modes.
; @param (WORD) %1: Pointer to the format string.
; @param (WORD) %2..%n: Values for the format string, note that those tokens are
; pushed as is on the stack when calling printf.
%macro _LOG 1-*
    %if __?BITS?__ == 16
    %error "_LOG not available in 16 bit mode"
    %endif

    PUSH_ALL_REGS

    %if __?BITS?__ == 32
    ; 32-bit mode
    SECTION .data.str progbits alloc noexec nowrite
    %%str:
    DB  %1, `\n`, `\0`
    SECTION .text
    BITS    32
    EXTERN  printf32
    %rep    (%0 - 1)
    %rotate -1
    push    %1
    %endrep
    push    %%str
    call    printf32
    add     esp, 0x4 * %0

    %else
    ; 64-bit mode.
    SECTION .data.str progbits alloc noexec nowrite
    %%str:
    DB  %1, `\n`, `\0`
    SECTION .text
    BITS    64
    EXTERN  printf64
    %rep    (%0 - 1)
    %rotate -1
    push    %1
    %endrep
    lea     rdi, [%%str]
    call    printf64
    add     rsp, 0x8 * (%0 - 1)

    %endif

    POP_ALL_REGS
%endmacro

; Call _LOG with a prefix. Not to be used as-is.
%macro _LOG_WITH_PREFIX 2-*
    %if %0 == 2
    _LOG    %strcat(%1, " ", %2)
    %else
    _LOG    %strcat(%1, " ", %2), %{3:-1}
    %endif
%endmacro

; Various level of logging.
%macro DEBUG 1-*
    _LOG_WITH_PREFIX "[DEBG]", %{1:-1}
%endmacro

%macro INFO 1-*
    _LOG_WITH_PREFIX "[INFO]", %{1:-1}
%endmacro

%macro WARN 1-*
    _LOG_WITH_PREFIX "[WARN]", %{1:-1}
%endmacro

%macro CRIT 1-*
    _LOG_WITH_PREFIX "[CRIT]", %{1:-1}
%endmacro

; Print a panic message and lock up the cpu. Used the same way as other logging
; macros.
; @param varags...: Same parameters as logging, e.g. formatted string formatted
; with zero or more values to be substitued. Can also be called with no
; arguments
%define PANIC _PANIC __?FILE?__, __?LINE?__,

; Only used by PANIC. DO NOT CALL THIS DIRECTLY.
; The only reason this exists is because of a bug in NASM where putting
; __?FILE?__ and __?LINE?__ in the body of multi-line macros does not report the
; correct file/line if the macro is included by another file and used there.
; Somehow single-line macros are not affected by this bug, hence the single-line
; macro PANIC acts as a "frontend" for _PANIC and passes it the correct file and
; line number as param (think of it at currying).
%macro _PANIC 2-*
    _LOG "==================== PANIC ===================="
    _LOG %strcat("  Location: ", %1, ":", %2)
    %if %0 > 2
    _LOG_WITH_PREFIX "  Reason:", %{3:-1}
    %endif
    _LOG "==============================================="
    ; The following gets assembled in the current BITS mode.
    %%dead:
    cli
    hlt
    jmp     %%dead
%endmacro

; Compute the value of a segment selector for GDT entry i.
%define SEG_SEL(i) (i << 3)

; Define a function that will be accessible from other files. The 16/32/64
; indicates the type of code this function holds and sets the BITS accordingly.
; @param: The name of the function to define.
%define DEF_GLOBAL_FUNC16(name) _DEF_GLOBAL_FUNC 16, name
%define DEF_GLOBAL_FUNC32(name) _DEF_GLOBAL_FUNC 32, name
%define DEF_GLOBAL_FUNC64(name) _DEF_GLOBAL_FUNC 64, name
; Helper macro for DEF_GLOBAL_FUNCXX. Do not use directly.
%macro _DEF_GLOBAL_FUNC 2
    SECTION .text
    BITS    %1
    GLOBAL  %2
    %2
%endmacro

; Define a function that will only be accessible from the current file, e.g.
; static linkage. The 16/32/64 indicates the type of code this function holds
; and sets the BITS accordingly.
; @param: The name of the function to define.
%define DEF_LOCAL_FUNC16(name) _DEF_LOCAL_FUNC 16, name
%define DEF_LOCAL_FUNC32(name) _DEF_LOCAL_FUNC 32, name
%define DEF_LOCAL_FUNC64(name) _DEF_LOCAL_FUNC 64, name
; Helper macro for DEF_LOCAL_FUNCXX. Do not use directly.
%macro _DEF_LOCAL_FUNC 2
    SECTION .text
    BITS    %1
    %2
%endmacro

; Define a variable accessible from all files.
; @param name: The name of the global variable.
%define DEF_GLOBAL_VAR(name) _DEF_GLOBAL_VAR name
%macro _DEF_GLOBAL_VAR 1
    SECTION .data
    GLOBAL  %1
    %1
%endmacro

; Define a variable only accessible from the current file, e.g. static var.
; @param name: The name of the global variable.
%define DEF_LOCAL_VAR(name) _DEF_LOCAL_VAR name
%macro _DEF_LOCAL_VAR 1
    SECTION .data
    GLOBAL  %1
    %1
%endmacro

%macro _EXT_SYM 1
    EXTERN  %1
%endmacro

%define EXT_FUNC(name) _EXT_SYM name
%define EXT_VAR(name) _EXT_SYM name

%endif
